/**********************************************************************
 *    IDENTIFICATION:
 *       gribsimp.c - Sample program to test the Grib Library;
 *	 decode a file with 1/more GRIB edition 1 messages;
 **********************************************************************/

/* INCLUDE STATEMENTS */
#include <stdio.h>
#include <limits.h>
#include <string.h>
#include <stdlib.h>
#include <values.h>
#include <dirent.h> 	/* for directory structures */
#include "grads.h" 	/* all GrADS structs */
#include "gsv5d.h"      /* local VIS5D structs (in addition to Vis5D's own) */
#include "isdb.h"  	/* date & reg_geom structs */
#include "grib_lookup.h" /* for Lookup structs */
#include "dprints.h"  	/* for Debug printing definitions */
#include "gribfuncs.h"  /* GRIB library function prototypes */

#define SOUTHPOLE  -89.999990	/* as close to +/-90 as possible w/o getting */
#define NORTHPOLE   89.999990	/* in latlon_xy(); */

#define TABLE_PATH        "../tables"   /* default dir of Lookup Tables */ 
#define SOFTWARE_VERSION  3.0           /* decoder version */
#define GRIB_EDITION      1             /* GRIB edition    */
#define FILL_VALUE        MAXFLOAT      /* default for missing dta pts */

#define USAGE		\
"\n\nCORRECT USAGE: \n" \
"gribsimp -i fn -d      -[ovb] -[I indx] -print -g [dtg lvl] "\
"-v5d dtg lvl [v5dfn]\n"\
"               -D [path]      -[X indx] -dump \n"\
"               -t \n"\
"               -s Tbl \n"\
"\n"\
"      -i  = specifies input file to process [REQUIRED]\n" \
"      -d  = ouput log to 'GRIB.log' (include first 100 data points\n" \
"      -D  = same as -d but also includes decoded table information.\n" \
"            An optional path to the Lookup Table may be specified\n" \
"      -s  = set local table explicitly  (implies -D)\n"  \
"      -t  = use WMO standard GRIB table (overides -s, implies -D)\n"  \
"      -o  = output binary data file(s) generated by gribsimp\n" \
"      -v  = echo current version numbers for decoder\n"  \
"      -b  = do not apply bit map section to data\n" \
"      -I  = create an index file of GRIB messages in the input file\n" \
"      -X  = decode only those messages listed in the named index file\n" \
"   -dump  = dump out as much info as possible from bad Message\n" \
"   -print = print the internal GRIB structures after decoding\n"\
"   -g [yyyymmddhh lvl] = create GrRADS control files (.gmp and .ctl) \n" \
"            Default is to use 1st message's base time and level id. \n"\
"            A date/time (of form yyyymmddhh) and a level id \n"\
"            may be specified explicitly to overide this. \n"\
"   -v5d yyyymmddhh lvl [v5dfn] = create a Vis5d file using the given\n"\
"            date time group and Level.  Output file name can be specified\n"\
"            as third argument, else default to format 'yyyymmddhh.lvl.v5d'.\n"\
"            This option is only available if gribsimp was compiled \n"\
"            with the Vis5D environment defined;\n"\
"\n"\
"Notes:\n"\
"   1) gribsimp only expects one of -d, -D, -s, or -t \n"\
"   2) The default order for the Path of the lookup table is\n" \
"             1) use path specified with -D\n" \
"             2) use Environment Variable GRIB_ENV \n"\
"             3) else defaults to #define variable TABLE_PATH (../tables) \n"\
"   3) -I and -X should not be used together.  The proper sequence is to \n"\
"      create an index file using -I, review/edit the index file, then use \n"\
"      it with -X.  The index file is tied to a specific input file.  \n"\
"      Therefore, when processing with -X the same input file used to \n"\
"      generate the index file must be used.\n"


extern int  	   UseTables;     	/* set if using Lookup tbl */
extern PARM_DEFN   db_parm_tbl [NPARM*MAX_PARM_TBLS];/* parm conversion info*/
extern LVL_DEFN    db_lvl_tbl [NLEV];   /* level conversion info  */
extern MODEL_DEFN  db_mdl_tbl [NMODEL]; /* model conversion info  */
extern GEOM_DEFN   db_geom_tbl [NGEOM]; /* Geom conversion info   */
extern CTR_DEFN	   db_ctr_tbl [NCTRS];  /* Center conversion info */

/*....................  Global Vars  ..............................*/
char *InFile = NULL;      /* input file name */
char *IndexFileName=NULL; /* name of the index file to use or produce */
char *Table_Path =NULL;   /* Local directory  where to find lookup tables */
char *Table_Name =NULL;   /* Name of file containing parameter/level tbls*/
int  make_log=0;          /* flag for whether to produce the full
			   or partial log file (or no log file at all) */
int  grib_defn = 0;       /* flag to use GRIB table only, with no
			   local definitions, (1 => use default GRIB) */
int  user_table = 0;      /* flag to use user-specified GRIB tables */
int  output_flag = 0;     /* flag signifying whether to produce a
			   flat file output or not */
int  Build_Index = 0;   /* if 1, build an Indexfile with each Msg's info&addr;*/
int  Read_Index = 0;    /* if 0, decode all msgs in input file;  if 1, */
			/* decode only the msgs listed in the IndexFile */
int  SkipBitmap = 0;    /* default to always using Bitmap  */
int  Make_Grads = 0;    /* whether to make GrRADS control files */
int  grad_full = 0;     /* set if out of extensions used in varname */
int  Make_V5d  = 0;     /* whether to make Vis5D control files */
int  Prt_Internals = 0; /* whether to print internal structs after decoding */
int  dump = 0;		/* dump out what is possible from bad message */
FILE *IndexFile = NULL; /* file where the index will be written/read from,  */
			/* depending on the user specified command-line flags */
BMS_INPUT	 bms;	/* input structure for bitmap section   */
PDS_INPUT        pds;   /* product definition section */
grid_desc_sec    gds;   /* grid description section */
BDS_HEAD_INPUT   bds_head;  /* input structure for bds section */
GRIB_HDR 	 *gh1=NULL; /* holds Msg and its info */
GRAD_INFO  	 grad_info; /* holds common info for Grads control files */
grid_desc_sec    grad_gds;   /* Grads dataset's grid description section */

#ifdef V5D_ON
/* Vis5D relared variables */
V5_INFO    v5d_info;	/* holds common info for Vis5D control files */
char       *v5d_outfile=NULL;   /* optional cmd line argument */
int	   v5d_parm_cnt=0;	/* number of V5D unique Params */
int	   v5d_lvl_cnt=0;	/* # of V5D unique Levels, should only be 1 */
int 	   v5dcnt = 0;		 /* # addresses stored in v5d index array */
V5_REC     *v5d_msgs_head=NULL;  /* head of V5d Messages list */
V5_REC     *v5d_msgs_tail=NULL;  /* tail of V5d Messages list */
V5_REC	   *v5dmsg;
V5D_PARM  *v5d_parm_head=NULL;  /* head of V5d Param list */
V5D_PARM  *v5d_parm_tail=NULL;  /* tail of V5d Param list */
V5D_LVL   *v5d_lvl_head=NULL;   /* ptr to V5d Level info */
#endif


/*......................................................................*/
void main (argc, argv) 
int argc; 
char **argv; 
{
char    errmsg[2000];    /* error msgs back from Grib library */
char    buffer[200]; /* name of look up file to load, w/ abs. path */
char    prev_lookupfn[200]; /* name of Lookup table previously loaded */
int	Skip;		/* working var */
int 	i;		/* working var */
int	ftp_already;    /* set if current file has already been transfered */
int	idtg;		/* current Grads Dtg */
int	grad_msgs=0;	/* number of Grads messages so far;  this may not be */ 
			/* same and #valid Grib msgs found sofar, because    */
			/* the -g (grads) option doesn't support: 	*/
			/* -> Layers, Unit greater than year, bad GrdSz */
int	decoded_cnt=0;  /* number of messages decoded successfully */
int	grad_parm_cnt=0;	/* number of Grads unique Params */
int	grad_lvl_cnt=0;	/* number of Grads unique Levels */
int     nReturn=0;      /* return status from Grib_dec           */
long    offset;   	/* offset within the multiple GRIB file, indicating */
		        /* end of current msg relative to the top of the file*/
unsigned long   msg_length = 0; /* the total length of the message */
float *grib_data=NULL;  /* array of decoded data values */

FILE *fpo= NULL;        /* output IEEE file name */

/* GRADS relared variables */
GRAD_REC   *grad_msgs_head=NULL; /* head of Grads Messages list */
GRAD_REC   *grad_msgs_tail=NULL; /* tail of Grads Messages list */
GRAD_REC   *tmp_grad_msg; 	 /* temp ptr */
GRAD_PARM  *grad_parm_head=NULL; /* head of Grads Param list */
GRAD_PARM  *grad_parm_tail=NULL; /* tail of Grads Param list */
GRAD_PARM  *tmp_parm; 	 /* temp ptr */
GRAD_LVL   *grad_lvl_head=NULL;  /* head of Grads Level List */
GRAD_LVL   *grad_lvl_tail=NULL;  /* tail of Grads Level List */
GRAD_LVL   *tmp_lvl=NULL; 	 /* ptr to level list for Grads cntrl files  */


   fprintf(stdout,"\nGRIBSIMP Execution...\n\n");
/*
* A.1       Initializes variables
*/
   errmsg[0] = '\0';
   prev_lookupfn [0]= '\0';

/*
*
* A.2       FUNCTION ParseInput  !exit on error
*           !if making grads files, appropriate vars have been initialized
*           !if using decoder Lookup tbl then its Path has already been verified
*           !if reading indexfile then it's already opened for reading
*           !if creating indexfile then it's already opened for writing
*/
   switch ((nReturn = ParseInput (argc, argv, errmsg))) {
	case +1:   /* no error if only -v selected */ goto bail_out; 
	case -1:   fprintf(stderr, "%s\n", USAGE); goto bail_out; 
   }

/*
*	
* A.3       IF (Not reading the offset from Indexfile )
*           THEN
*               DEFAULT with file offset of zero
*           ELSE
*               FUNCTION next_index_entry !get offset of next Msg from Indxfile
*               IF (failed) THEN
*                   PRINT error
*                   EXIT program
*                ENDIF
*           ENDIF
*/
   if (! Read_Index) offset= 0L;
   else if ((nReturn= next_index_entry(&offset, errmsg)) != 0) {
	  if (decoded_cnt == 0) 
	  sprintf(errmsg, "IndexFile '%s' has no valid entries\n", 
	  IndexFileName);
	  goto bail_out;
	  }
/*
*
* A.4       IF (using Lookuptbl) THEN
*/
       if ( UseTables )    /*  (-D option) Load ORIG_CTRS only once    */
        {	    /* let program proceed even if unable to load file */
	   
/*
* A.4.1        WHILE unable to open "orig_ctrs" for reading 
*                    AND no attempt has been made to ftp file from remote site 
*              DO
*                   FUNCTION FTP_getfile	!go get file from remote site
*                   SET flag to mark ftp has been done
*              DONE
*/
	   ftp_already = 0;
	   sprintf(buffer, "%s/orig_ctrs", Table_Path);
	   while ( (fpo= fopen(buffer,"r")) == NULL &&  ftp_already==0 ) {
		/* 
		   Don't want to abort if ftp call fails so not checking 
		   result of ftp call
		*/
		DPRINT1("'%s' not avail locally.  Will try to ftp;\n",buffer);
		FTP_getfile ("orig_ctrs", Table_Path, errmsg);
		ftp_already = 1;
	     }

/*
* A.4.2        IF file is available for reading 
*              THEN
*                   FUNCTION ld_grib_origctrs    !$table_path/orig_ctrs
*                   IF error PRINT warning message but let the program
*                   proceed (treat as "soft" error)
*              ENDIF
*/
	   if (fpo != NULL) {  /* Orig_Ctrs avail, so go load it */
	        fclose(fpo);	/* close temp file ptr */
	        if (ld_grib_origctrs("orig_ctrs", Table_Path, errmsg) != 0) 
		    {  	
		     /* load failed */
	             fprintf(stdout,"WARNING:  %s;\n", errmsg); 
		     errmsg[0]='\0'; 
		    } 
                }  
	   else {	/* no file, treat as "soft error" & continue */
		fprintf(stdout,
		"Warning:  unable to get remote file 'orig_ctrs', "\
		"proceed anyway\n\n");
		memset((void*)db_ctr_tbl, '\0', NCTRS*sizeof(CTR_DEFN));
	        }
/*
* A.4       ENDIF          !using table
*/
      } /* using tbles */ 

   errmsg[0] = '\0';

/*
* A.5       MAKE storage for Grib Header !exit on error
*/
   if ((nReturn= init_gribhdr (&gh1, errmsg) ))  goto bail_out; 

/*
*
* A.6       WHILE (infinite loop)
*/
while  (1)
{
/*
* A.6.1       FUNCTION grib_seek    !find next GRIB msg starting at Offset
* A.6.1.a     If (fails) THEN
*                  GO clean house & quit
*/
  if  (nReturn= grib_seek(InFile, &offset, Read_Index, gh1, errmsg)) break;

/*
* A.6.1.b     ELSE check if got a Warning from GribSeek THEN 
*                PRINT warning
*                CLEAR out error array & loop   !skip decoding
*/
  else /* NO errors but got a Warning msg from seek */
  	if (errmsg[0] != '\0')  
   	{ fprintf(stdout,"%s; Skip Decoding...\n",errmsg);  errmsg[0]='\0'; }


/*
* A.6.1.c       ELSE IF (message has more than 0 bytes) THEN
*/
  else if ((msg_length = gh1->msg_length) > 0) {
/*
* A.6.1.c.1        FUNCTION init_dec_struct   !init decoder structures
*/
      fprintf(stdout,"Decoding message found at %ld bytes ...\n",offset);
      init_dec_struct(&pds,&gds,&bms,&bds_head);

/*
* A.6.1.c.2        FUNCTION grib_dec      !perform GRIB decoding
*                  IF (error decoding message)
*                      GO clean house & quit
*                  ENDIF
*/
      grib_data=NULL;        
      if (nReturn = grib_dec ((char *)gh1->entire_msg, 
				&pds, &gds, &bds_head, &bms, 
			      &grib_data, errmsg)) goto bail_out;
      decoded_cnt++;

/*
* A.6.1.c.3      IF (applying Bitmap Section to Data AND 
*                    Bitmap Section is present) 
*                THEN
*                    FUNCTION apply_bitmap !apply BMS to 'grib_data'
*                    IF (error applying bitmap) THEN
*                        EXIT
*                    ENDIF
*                ENDIF
*/
      if (!SkipBitmap && bms.uslength>0)
      if (nReturn=apply_bitmap(&bms, &grib_data, FILL_VALUE, &bds_head,errmsg))
	  goto bail_out; 
/*
* A.6.1.c.4       IF (using external Decoder Lookup Table) 
* A.6.1.c.4.1     THEN   
*                    FORM the name of Decoder Lookup TableName to use
*                    ! the cmdline options determine which lookup table is used;
*                    ! Option order is :
*                    !  (-t): use default GRIB Tble= g{Edition}tab_{ParmTbl};
*                    !  (-s): use Tbl specified on comand line
*                    !  (-D, no -t, no -s): use Originating Center's local tbl
*                    !   if Sub Center Id (non-0, non-255) is avail, use:
*                    !   g{Edition}tab_{CtrId}.{SubCtrId}_{usParmtbl}.{usSubtbl}
*                    !   else use:
*                    !   g{Edition}tab_{CtrId}_{usParmtbl}.{usSubtbl}
*                 ENDIF
*/
      if(UseTables)   /* (option -D) depends on Edition, Parm#/SubParm#, Ctr */
      {
         if (grib_defn)  { /* (option -t) use g[$Edit]tab_[$pds.ParmTbl] */
		if (!(Table_Name = (char *)malloc(15))) {
		   sprintf(errmsg, "Malloc Table_Name failed (grib_defn)\n"); 
		   goto bail_out; }
		sprintf(Table_Name,"g%01utab_%u", pds.usEd_num,pds.usParm_tbl);
		}

       /* else if (user_table)  /#  (option -s) #/
		  {  do nothing, TblName given on Cmdline; }
	*/

         else if (!user_table) { /* (-D only,   no -t, no -s) */
		if (!(Table_Name = (char *)malloc(25))) {
		   sprintf (errmsg,"Malloc Table_Name failed (! user_table)\n");
	   	    goto bail_out;
		  }
		if (pds.usCenter_sub!= 0 && pds.usCenter_sub!=255) {
		   sprintf(Table_Name,"g%01utab_%u.%u_%u.%u",
         	   pds.usEd_num,
		   pds.usCenter_id, pds.usCenter_sub, 
		   pds.usParm_tbl, pds.usSub_tbl);
		   DPRINT3("usCenter_id =%d, usCenter_sub=%d, so fn=%s\n",
		   pds.usCenter_id, pds.usCenter_sub, Table_Name);
		  }
		else {
		   sprintf(Table_Name,"g%01utab_%u_%u.%u",
         	   pds.usEd_num,
		   pds.usCenter_id, 
		   pds.usParm_tbl, pds.usSub_tbl);
		   DPRINT3(
		   "usCenter_id =%d, (not using usCenter_sub=%d), so fn=%s\n",
		   pds.usCenter_id, pds.usCenter_sub, Table_Name);
		}
	  }

/*
* A.6.1.c.4.2      IF (this Lookup file was not the one previously loaded)
*                  THEN
* A.6.1.c.4.2.1         LOOP while (unable to open LOOKUP file for reading) 
*                         IF (haven't ftp-ed yet) THEN     
*                             FUNCTION FTP_getfile   !get it from remote Host
*                             SET already_ftp flag
*                         ELSE !already ftp-ed  but still cannot open file
*                             RETURN, skip loading this file;
*                         ENDIF
* A.6.1.c.4.2.1         ENDLOOP

* A.6.1.c.4.3           FUNCTION ld_dec_lookup  !load GRIB Decoder Lookup table
* A.6.1.c.4.4           SAVE name of lookup file just loaded
*                  ENDIF
*/

	 /*
	 Make sure Lookup file  exists, else download fr. remote HOST;
	 */
	 sprintf(buffer, "%s/%s", Table_Path, Table_Name);
         if (strcmp (prev_lookupfn, buffer)) 
	 {
	   ftp_already = 0;
	   while ( (fpo= fopen(buffer,"r")) == NULL &&  ftp_already==0 ) {
		/* 
		   Don't want to abort if ftp call fails so not checking 
		   result of ftp call
		*/
		DPRINT1("'%s' not avail locally.  Will get from remote site;\n"
		,buffer);
		FTP_getfile (Table_Name , Table_Path, errmsg);
		ftp_already = 1;
	     }

	   if (fpo == NULL) { 	/* file NOT avail, */
				/* treat as "soft error" & continue */
		   if (errmsg[0]!='\0') {
		        fprintf(stdout,
			"Warning: %s not avail because=\n%sproceed anyway;\n\n",
			Table_Name, errmsg);
			errmsg[0]= '\0';
			}
		   else fprintf(stdout,
		   	"Warning:  '%s' not available at remote site,"\
		        " proceed anyway;\n",   Table_Name);

		   /*  	
			clear all incase they're from a different table 
		   	that was previously loaded 
		   */
		   memset((void *)db_parm_tbl, '\0',
                   MAX_PARM_TBLS * NPARM * sizeof(PARM_DEFN));
                   memset((void *)db_lvl_tbl, '\0', NLEV * sizeof(LVL_DEFN));
                   memset((void *)db_mdl_tbl, '\0', NMODEL *sizeof(MODEL_DEFN));
                   memset((void *)db_geom_tbl,'\0', NGEOM * sizeof(GEOM_DEFN));
                   prev_lookupfn[0] = '\0';
	      }
	   else {  		/* File is avail, so go load it */
	        fclose(fpo);

	      /* 
		 Load Decoder Lookup file '$Table_PAth/$Table_NAme' 
                 into arrays db_(mdl/lvl/parm/geom)_tbl;
	         note that this function will automatically ftp the file 
		 from remote site if it's not avail locally.
	       */
                if ( ld_dec_lookup (buffer, errmsg) == 0) {
		   /* successful */
		   strcpy (prev_lookupfn, buffer);	  
	           fprintf(stdout,"-> LookupTbl '%s'\n", buffer);	
		  }
		else 	/* Failed */
		  {	
	           fprintf(stdout,"WARNING: %s; ignore & proceed;\n", errmsg); 
		   errmsg[0]='\0'; 
		   /* 
		     	clear in case they contain data from another tbl 
		   */
		   memset((void *)db_parm_tbl, '\0',
                   MAX_PARM_TBLS * NPARM * sizeof(PARM_DEFN));
                   memset((void *)db_lvl_tbl, '\0', NLEV * sizeof(LVL_DEFN));
                   memset((void *)db_mdl_tbl, '\0', NMODEL *sizeof(MODEL_DEFN));
                   memset((void *)db_geom_tbl,'\0', NGEOM * sizeof(GEOM_DEFN));
                   prev_lookupfn[0] = '\0';
		  }  /* bad load */
	      }
	 } /* new LookUp file */

	 if (grib_defn || !user_table) free(Table_Name);

/*
* A.6.1.c.5       ENDIF     !using tables
*/
      } /* usetables */

/*
* A.6.1.c.6      IF (printing of Internal Structs desired) THEN
*                    FUNCTION prt_inp_struct  !show internal structs
*                ENDIF
*/
     if (Prt_Internals) 
     {
         fprintf(stdout, "Content of Internal GRIB Structures=\n");
         prt_inp_struct(&pds, &gds, &bms, &bds_head, &grib_data); 
     }


/*
* A.6.1.c.7       IF (creating Binary output file) THEN
*/
      if(output_flag)
      {
/*
* A.6.1.c.7.1        MAKE name of output flat file
*                  !name varies depending on which Table 2 is used
*                  !'F''X'yymmddhhTTTPID.GID.LID.level where
*                  !   X is 'F' if using Main Table 2, or 'A/B/C/D/E'
*                  !      depending on which Sub Table 2 being used
*                  !   TTT is 3 digit pds.usP1
*                  !   PID is 3 digit (pds.usParm_id or pds.usParm_sub)
*                  !   GID is 3 digit pds.usGrid_id
*                  !   LID is 3 digit pds.usLevel_id
*                  !   level is 5 digit pds.usHeight1
*/
         if (pds.usParm_id > 249 && pds.usParm_sub!=999)
             sprintf(buffer,
                "F%c%02u%02u%02u%02u%03u%03u.%03u.%03u.%05ld",
                pds.usParm_id-250 + 'A',
                pds.usYear, pds.usMonth, pds.usDay, pds.usHour,
                pds.usP1, pds.usParm_sub, pds.usGrid_id,
                pds.usLevel_id, pds.usHeight1);
         else
             sprintf(buffer,
                "FF%02u%02u%02u%02u%03u%03u.%03u.%03u.%05ld",
                pds.usYear, pds.usMonth, pds.usDay, pds.usHour,
                pds.usP1, pds.usParm_id, pds.usGrid_id,
                pds.usLevel_id, pds.usHeight1);

/*
* A.6.1.c.7.2        OPEN flat file for writing
*                  WRITE Data array grib_data to flat file
*                  CLOSE flat file
*/
         fprintf(stdout,"Creating flat file= '%s'\n",buffer);
         fpo = fopen(buffer, "wb");
         fwrite(grib_data, sizeof(float), bds_head.ulGrid_size, fpo);
         fclose(fpo);
/*
* A.6.1.c.7       ENDIF   !create Binary file
*/
      }

/*
* A.6.1.c.8       IF (creating Log file) THEN
*                  FUNCTION make_grib_log   !write summary info to GRIB.log
*               ENDIF
*/
        if (make_log   && 
	  make_grib_log (InFile, prev_lookupfn, msg_length, offset,
                        pds, gds, bds_head, bms, grib_data, errmsg)) 
	 {
	  fprintf(stdout,"Warning: %s;  ignore & continue\n",errmsg);
	  errmsg[0]= '\0';
	  }


/*
* A.6.1.c.9       IF (creating GRADS control files 
*                     AND still accepting more Grads Messages
*                     AND either Spherical or Lambert Conformal Projection)
*                 THEN
*/
   if (Make_Grads && !grad_full 
	&& (gds.head.usData_type==LATLON_PRJ 
	     || gds.head.usData_type==LAMB_PRJ)  )
   {
/*
* A.6.1.c.9.1         CALCULATE msg's reference time !yyyymmddhh
*/

            idtg = (pds.usCentury-1)*100000000 + pds.usYear*1000000 +
                pds.usMonth*10000 + pds.usDay*100 + pds.usHour;
/*
* A.6.1.c.9.2.a       IF (Level is not a single layer )
*                        PRINT error message !skip this msg in Grads files
*/
        if (pds.usLevel_id==101 ||pds.usLevel_id==104
          || pds.usLevel_id==106 || pds.usLevel_id==108
          ||pds.usLevel_id==110 ||pds.usLevel_id==112
          || pds.usLevel_id==114 ||pds.usLevel_id==121
          ||pds.usLevel_id==128 || pds.usLevel_id==141)

            /* GRads doesn't support: Layers, Unit>year, bad GrdSz */
            fprintf(stdout,
           "Warning:  Layers not supported, only single levels\n"
           "Grads skipping:  [ %02d/%02d/%02d%02d %02d:%02d ], LEVEL=%d\n\n",
            pds.usMonth, pds.usDay, pds.usCentury, pds.usYear,
            pds.usHour, pds.usMinute, pds.usLevel_id);
          
/*
* A.6.1.c.9.2.b       ELSE if (Level is not a single layer )
*                        PRINT error message !skip this msg in Grads files
*/
        else if (pds.usFcst_unit_id >= 8 && pds.usFcst_unit_id <=253)
            /* Unit>year */
            fprintf(stdout,
           "Warning:  unsupported forecast period unit\n"
           "Grads skipping: [ %02d/%02d/%02d%02d %02d:%02d ] FCST_UNIT=%d\n\n",
            pds.usMonth, pds.usDay, pds.usCentury, pds.usYear,
            pds.usHour, pds.usMinute, pds.usFcst_unit_id);

/*
* A.6.1.c.9.2.c       ELSE if (grid size in BDS is bad)
*                        PRINT error message !skip this msg in Grads files
*/
	else if ( bds_head.ulGrid_size <= 0 ) /* bad grid size */
            fprintf(stdout,
           "Warning:  bad ulGrid_size detected in BDS\n"
           "Grads skipping: [ %02d/%02d/%02d%02d %02d:%02d ] ulGrid_size=%ld\n\n",
            pds.usMonth, pds.usDay, pds.usCentury, pds.usYear,
            pds.usHour, pds.usMinute, bds_head.ulGrid_size);
          
/*
* A.6.1.c.9.2.d       ELSE if base time is earlier than the accepted base time
*                        PRINT message    !skip this msg in grads files
*/
        else if (idtg < grad_info.base_dtg)
               fprintf(stdout,
		"Grads skips> %02d%02d%02d%02d%02d "
                "Pid/sub=%d, Lvl=%d Ht=%d, Sz=%ld (earlier DTG)\n",
                 pds.usCentury-1, pds.usYear, pds.usMonth, pds.usDay,
                 pds.usHour, PARMTBL_INDX(pds.usParm_id,pds.usParm_sub),
		pds.usLevel_id, pds.usHeight1, bds_head.ulGrid_size);
                
/*
* A.6.1.c.9.2.e       ELSE if (Grid Size has been defined AND is different
*                              from current msg's Grid Size)
*                        PRINT message    !skip this msg in grads files
*/
        else if  (grad_info.ulGrid_size!=999 &&
                    bds_head.ulGrid_size != grad_info.ulGrid_size )
                fprintf(stdout,
		 "Grads skips> %02d%02d%02d%02d%02d "
                 "Pid/sub=%d, Lvl=%d Ht=%d, GridSz=%ld (different than %ld)\n",
                 pds.usCentury-1, pds.usYear, pds.usMonth, pds.usDay,
                 pds.usHour, PARMTBL_INDX(pds.usParm_id,pds.usParm_sub),
		 pds.usLevel_id, pds.usHeight1, bds_head.ulGrid_size,
		 grad_info.ulGrid_size);
		 
/*
* A.6.1.c.9.2.f       ELSE call FUNCTION ld_grad_msg
*                        IF malloc error or Internal error
*                           PRINT error message
*                           BRANCH to clean up & exit
*                        ENDIF
*/
            else if ((nReturn= ld_grad_msg (&grad_full, offset,
			     pds, gds, bds_head, bms, 
			     &grad_parm_cnt, &grad_lvl_cnt, &grad_msgs,
			     &grad_parm_head, &grad_parm_tail, 
			     &grad_msgs_head, &grad_msgs_tail,
			     &grad_lvl_head, &grad_lvl_tail,    
			     &grad_info, errmsg) ))
                    goto bail_out;
               

/*
* A.6.1.c.9.2.g       ELSE IF this is the first message in Grads dataset
*                        MAKE a copy of the accepted GDS block
* A.6.1.c.9.2         ENDIF
*/
	    else if (grad_msgs == 1) 
	        memcpy((void*) &grad_gds, (void*) &gds, sizeof(grid_desc_sec));
               
/*
* A.6.1.c.9       ENDIF !creating Grads
*/
      } /* MAkeGrads */

/*
*
* A.6.1.c.10       IF (option Vis5D was used  
*                    AND (this message's Level matches the V5D Level type OR
*                        (V5D level is 105 and current level is 1 or 102))
*                    AND (this is 1st message OR geom matches V5d geometry)
*                    AND (this is 1st message OR model matches V5d model)
*                     )
*                  THEN
*                     !Levels 1 and 102 will be treated like Level 105;
*                     !It is assumed that all of these messages with 
*                     !levels 001 and 102 all have Height=00000;
*
*                      CALCULATE the date time group of this message
*                      IF (Message's base time is same or later than
*                             the User-provided V5D basetime )
*                      THEN
*                          IF (no more space to hold this V5d address) THEN
*                             DISPLAY warning  !drop this msg
*                          ELSE
*                             SAVE the address of this message in the
*                             Vis5d address array
*                             INCREMENT count of V5D messages
*                          ENDIF
*                      ENDIF
*                  ENDIF
*/
#ifdef  V5D_ON
    if (Make_V5d 
     && (pds.usLevel_id==v5d_info.zdef_lvl ||
	(v5d_info.zdef_lvl==105 && (pds.usLevel_id==1 || pds.usLevel_id==102)))
     && (pds.usGrid_id==v5d_info.usGeom || v5d_info.usGeom==USHRT_MAX )
     && (pds.usProc_id==v5d_info.usModel || v5d_info.usModel==USHRT_MAX )

     && (nReturn=Process_v5d(offset, errmsg)) != 0)  
    goto bail_out;
     /* makeV5D */
#endif

/*
* A.6.1.c.11      IF (float array have data in it) THEN
*                    FREE up its storage;
*                 ENDIF
*/
      if (grib_data!=NULL) { free(grib_data); grib_data = NULL; }

/*
* A.6.1.c.12      IF (building an Indexfile) THEN
*                    APPEND info from this message to Index file
*                    !format: yy-mm-dd-hh-P1-Parm-Sub-Level-Height-Gridid-offset
*                 ENDIF
*/
      if(Build_Index) 
		fprintf(IndexFile,
		"%02u-%02u-%02u-%02u-%03u-%03u-%03u-%03u-%05u-%03u-%ld\n",
                pds.usYear, pds.usMonth, pds.usDay, pds.usHour,
                pds.usP1, pds.usParm_id, pds.usParm_sub,
                pds.usLevel_id, pds.usHeight1, pds.usGrid_id, offset);

/*
* A.6.1.c        ENDIF 
*/
   } /* got  MsgLen > 0 bytes */
/*
* A.6.1.d        ELSE  set msg_length to dummy 1
*/
  else msg_length = 1L;

/*
*
* A.6.2         IF (not Reading offset from Indexfile )
*               THEN 
*                   bump offset to address after current message
*               ELSE 
*                   FUNCTION next_index_entry  failed   !get next offset 
*                   IF (Error) QUIT;
*                   IF (no more entries) THEN
*                       SET status to 2   !duplicate gribseek EOF code 
*                       QUIT loop;
*                   ENDIF
*               ENDIF
*/
   if (  ! Read_Index ) offset += (msg_length); 
   else {
	nReturn = next_index_entry(&offset, errmsg);
	if (nReturn == -1) 
		{ /* error */ goto bail_out; }
	else if (nReturn == 1) 
		{ /* saw end of indexfile, duplicate gribseek eof code */ 
		  nReturn=2; break; 
		}
	}

/*
*
* A.6.3         IF (next offset is bad)
*               THEN 
*                   BREAK out of inifite loop
*               ENDIF
*/
   if (offset < 0L) break;

/*
* A.6       ENDWHILE      !Infinite loop
*/
} /* while 1 */

/*
*
*           =================================================
*           !only get here if got through entire file without 
*           !any errors...
*           =================================================
*
* A.7       IF (no errors occurred in last while loop AND
*               grads control file requested AND 
*               accepted some grads msgs)
* A.7.a     THEN                   !go create Ctrl files
*/
   if (nReturn==2 && Make_Grads && grad_msgs>0)
     {
/*
* A.7.a.1       FOR each grad message DO
*                     IF (mesg's level is same as the Zdef level)
*                     BREAK;
*                 ENDDO
*/
        /* make sure Zdef level was used */
        for (tmp_lvl= grad_lvl_head; tmp_lvl!=NULL; 
					tmp_lvl=tmp_lvl->next)
            if (tmp_lvl->usLevel_id == grad_info.zdef_lvl) break;

/*
* A.7.a.2       IF (no message had Zdef level)
* A.7.a.2.a     THEN
*                     PRINT message
*                     LIST all the levels found in this file
*/
        if (tmp_lvl == NULL) 
	     {
	      for (buffer[0]='\0', i=0 ,tmp_lvl= grad_lvl_head; 
		tmp_lvl; tmp_lvl=tmp_lvl->next, i+=4)
		sprintf(buffer+i," %03d", tmp_lvl->usLevel_id);

              sprintf (errmsg, 
              	"GrRADS Level to enumerate (%04d) must be 1 of the levels "\
	      	"in file ==> [%s]", grad_info.zdef_lvl, buffer); 

	      nReturn = 1;
	      goto bail_out;
             }
/*
* A.7.a.2.b     ELSE
*                    DEBUG print
*                    FUNCTION make_grad_files   !quit on error
*/
        else {
              DPRINT3("grad_parms=%d, grad_msgs=%d, grad_lvls=%d\n",
			grad_parm_cnt, grad_msgs, grad_lvl_cnt);

              if ( (nReturn = make_grad_files (
			&pds, &grad_gds, &grad_info, grad_parm_cnt,
			&grad_parm_head, &grad_msgs_head, &grad_lvl_head,
			errmsg)))
		  goto bail_out;
/*
* A.7.a.2       ENDIF
*/
              }
/*
* A.7.a     ENDIF
*/
    } /* making grads control files   */


#ifdef  V5D_ON
/*
* A.8       !This section is included if V5D_ON is enabled;
*           IF (Vis5D option was selected AND there is data)
*           THEN
*/
    if (Make_V5d && v5dcnt > 0) {
/*
* A.8.1       IF (#Variables is less than 1 OR #leveltypes is not 1)
* A.8.1.a     THEN
*                 LOAD error message    !skip making V5d output
*/

        if ( v5d_parm_cnt < 1 || v5d_lvl_head==NULL)
	   sprintf(errmsg,"Cannot make V5D output, #HTS=0, v5d_parm_cnt=%d"
	   , v5d_parm_cnt);
/*
* A.8.1.b   ELSE FUNCTION make_v5e_file     !go make v5d output
*/
	else {
	     i= make_v5d_file (v5d_outfile, v5d_parm_cnt, 
			&v5d_msgs_head, &v5d_parm_head, &v5d_lvl_head, 
			v5d_info, errmsg);
	   }
/*
* A.8       ENDIF !Vis5D option 
*/
    }
#endif

bail_out:
/*
*
* A.8      IF (there is an error message) THEN
*              PRINT it out
*              /# FUNCTION display_gribhdr #/  !print content before crash 
*              CHANGE exit code to 1 if it's 0
*          ENDIF
*/
   if (errmsg[0] != '\0')
      {
	 fprintf(stderr, 
         "\n****** ERROR *****\n%s: %s\n\n" ,argv[0], errmsg); 

	   if (dump == 1) /* option -dump used */
		{
	 	fprintf(stdout, 
         	"\n****** ERROR *****\n%s: %s\n\n" ,argv[0], errmsg); 
		if (gh1!=NULL) prt_badmsg (gh1, errmsg);
		else fprintf(stdout,
		"No Grib Header structure avail for prt_badmsg to display\n");
		}

   	 /*  display_gribhdr(gh1);    Print what we've got before the Crash */
	 if (nReturn==0) nReturn=1;
      }
/*
*
* A.9       CLEAN up before leaving
*           !free up Grib Header struct
*           !free data array if defined
*           !close index file if opened;
*           !free up all arrays holding lookup info
*           !free up all Vis5d linked lists if Vis5d option used;
*           !free up all GrRADS linked lists if Grads option used;
*/
   free_gribhdr (&gh1); 
   if (grib_data!=NULL) free(grib_data);
   if (IndexFile!=NULL) fclose(IndexFile);

#ifdef V5D_ON
   if (Make_V5d) {

	if (v5d_msgs_head != NULL) {
           while (v5d_msgs_head->next != NULL)
           { v5d_msgs_head=v5d_msgs_head->next; free(v5d_msgs_head->last); }
	   free (v5d_msgs_head);  /* and the last one too */
	}

	if (v5d_parm_head != NULL) {
           while (v5d_parm_head->next != NULL)
           { 	
		v5d_parm_head = v5d_parm_head->next; 
		free(v5d_parm_head->last); 
	   }
	   free (v5d_parm_head);  /* and the last one too */
  	}
	
	if (v5d_lvl_head != NULL) free (v5d_lvl_head);/* only 1 of a kind */
	if (v5d_outfile != NULL) free(v5d_outfile);
     }
#endif

   if (Make_Grads) { 
            while (grad_msgs_head != NULL)
           { tmp_grad_msg=grad_msgs_head; grad_msgs_head=grad_msgs_head->next; 
	     free(tmp_grad_msg); }
	   while (grad_parm_head!=NULL)
           { tmp_parm=grad_parm_head; grad_parm_head=grad_parm_head->next; 
	     free (tmp_parm); }
            while (grad_lvl_head!=NULL)
           { tmp_lvl=grad_lvl_head; grad_lvl_head=grad_lvl_head->next; 
	     free (tmp_lvl); }
      }
   
  if (nReturn==0 && InFile!=NULL && decoded_cnt==0) 
  fprintf(stdout, "No GRIB messages decoded from '%s'\n", InFile);
  else if (nReturn==2) nReturn=0;  /* change Eof status to Good status */

/*
*
* A.10      EXIT PROGRAM
*/
  DPRINT1 ("Exiting program with status= %d\n", nReturn);
  exit (nReturn);
/*
*
* END OF FUNCTION
* 
*/ 
}

/*
* =====================================================================
* B.  FUNCTION: ParseInput 
*     PURPOSE:  parse the command line and set up appropriate global
*               flags depending on user request;
*     INPUT  :  the command line & Error array;
*     RETURNS:  0 if success, -1 if error, and +1 if nothing requested;
*     NOTES  :  returns error if the following conditions aren't true:
*     -must specify input filename;
*     -cannot request to create index file and at the same time
*      process from an existing index file;
*     -must request to create either log file, binary output file,
*      or index file;
* =====================================================================
*/
#if PROTOTYPE_NEEDED
int     ParseInput (int argc, char **argv, char *errmsg)
#else
int     ParseInput (argc, argv, errmsg)
int     argc;
char 	*argv[]; 
char 	*errmsg;
#endif
{
   char		temp[200],*ddir, *str, *func="ParseInput";
   char         version_requested='\0';
   int          i, stat = -1;
   DATE		date;
   double	hour;
   DIR          *dfd;  /* dir struct to verify path */
   void h_e_time ();

 DPRINT1("Entering %s\n", func);
  if (argc == 1) {
       sprintf (errmsg,"%s:  no command argument detected",func);
       goto BYE;
   }

/*
* B.1       WHILE (more arguments on command line)
*/
  for (UseTables=0, i=1; str=argv[i]; ++i)
/*
*             IF (argument)
*                 -i = input file to process; error if filename is missing;
*                 -o = output binary data file(s) generated by gribsimp;
*                 -b = do not apply bit map section to data;
*                 -d = write log output into file GRIB.log;
*                 -D = write log output into file GRIB.log, including
*                      decoded table information; check for an Optional
*                      Path to the Lookup Tables;
*              -dump = print as much info as possible from bad message
*             -print = print the internal GRIB structures after decoding\n"
*                -g  = create GrRADS control files (.gmp and .ctl)
*                      using 1st msg's base time, level id as default;
*         -g yyyymmddhh zdef_lvl =
*                      create GrRADS control files using the specified
*                      date time group and level id as default;
*                 -s = set local table explicitly; Used with -D only;
*                      error if Table Version is missing;
*                 -t = use GRIB standard table (overides -s); Used w/ -D only;
*                 -v = echo current version numbers for decoder and tables;
*       -v5d yyyymmddhh zdef_lvl [v5doutfile] = 
*                      create vis5D output file using the given DTG, Leveltype
*                      and optional output filename.  When filename is not given
*                      program will assign one with format 'YYYYMMDDHH.lvl.v5d'
*                      Only available when program
*                      was compiled with Vis5D environment defined;
*                      Forces Lookup table usage.
*          -I indxfn = generate an Index file of GRIB messages found in infile;
*          -X indxfn = decode only those messages listed in the Index file;
*            otherwise,  Return Error Status;
*            ENDIF
*/
    if (!strcmp (str, "-b")) SkipBitmap = 1;
    else if (!strcmp (str, "-dump")) {
	 dump = 1;
	}
    else if (!strcmp (str, "-D")) 
	{
            /* check for Optional Path */
            if ((str=argv[i+1]) != (char *)0 && *str!='-') {
               if (Table_Path)
                  {sprintf(errmsg,"%s: multiple '-D' used\n", func);goto BYE;}
                else Table_Path= argv[++i];    /* save path */
            }
            make_log = 1;
            UseTables = 1;
         }
    else if (!strcmp (str, "-d")) {
	    if (UseTables == 1) {
		sprintf(errmsg,"%s: cannot use -d together with -D/-t/-s opts",
		func);  goto BYE; 
		}
	    make_log = 1;    /* -d option */
	 }
    else if (!strcmp (str, "-print")) Prt_Internals = 1;
    else if (!strcmp (str, "-o")) output_flag = 1;
    else if (!strcmp (str, "-i")) {
             if (InFile != NULL || (str=argv[++i])==NULL || *str=='-') {
               	sprintf (errmsg,
	        "%s: use Option '-i' Once followed by Inputfilename", func); 
		goto BYE; 
	        }
             InFile = str;
        }
    else if (!strcmp (str, "-s")) {
           if (user_table || (str=argv[++i]) == NULL || *str=='-') {
               	sprintf (errmsg,
	        "%s: use Option '-s' Once followed by Table filename", func); 
		goto BYE; } 

	   if (grib_defn == 1) {   /* option -t already used, drop -s  */ 
		fprintf(stdout,
		"%s: Option -t overrides -s option, (will not use %s)...\n",
		func, str); continue; }
	   else {		   /* only Load -s if no -t was used */
		user_table = 1;    /* -s option */
		Table_Name = str;  /* load -s tblname */
	   	make_log = 1;      /* implies -D option */
	   	UseTables = 1;     /* implies -D option */
		}
        }
    else if (!strcmp (str, "-t")) {
	   if (user_table==1) {   /* -s was used previously */
	   	fprintf(stdout,
	      "%s: Option -t overrides -s (drop previously loaded %s)...\n"
		,func, Table_Name);
		user_table=0;  	     /* drop previously loaded -s option */
		Table_Name= NULL;    /* and -s lookup filename too */
		}

	   grib_defn = 1;  /* -t option */
	   make_log = 1;   /* implies -D option */
	   UseTables = 1;  /* implies -D option */
	}
    else if (!strcmp (str, "-v")) {
                fprintf(stdout,
		"Software release: %.1f\n" \
		"GRIB standard version: %d\n" \
		"Grib Libray version in %s mode\n",
		SOFTWARE_VERSION, GRIB_EDITION, LIB_VERSION);
		version_requested = 1;
        }
    else if (!strcmp (str, "-v5d")) {   /* Vis5D option */
 
#ifndef  V5D_ON
	    fprintf(stdout,
	    "ERROR:  Option -v5d is only available when gribsimp has been\n"\
	    "compiled with vis5D extensions included.\n");
	    goto BYE;
#else
   	    memset ((void*) &v5d_info, '\0', sizeof(V5_REC));

	    if (Make_V5d == 1) {	/* already called once */
		sprintf (errmsg,
                "%s: use Option '-v5d' ONCE only please!", func); goto BYE;
                }

	    /* Get DTG and Level */
		if ( !(str=argv[++i]) || strlen(str) != 10
                        || strspn(str,"0123456789") != 10) {
		    sprintf(errmsg,
		    "%s:  no DTG/Level included with -v5d option\n",
		    func);  goto BYE;
		} 
             /* extract dtg */
             if (sscanf (str, "%d", &v5d_info.base_dtg)!= 1) {
                 sprintf(errmsg,
                 "Invalid DTG='%s' in option -v5d (expecting yyyymmddhhmm)\n"
                 , str);  goto BYE;
                }

             /* if DTG was entered, must also have Level */
             if ( !(str=argv[++i]) || !strlen(str) ||
                   strspn(str,"0123456789")!=strlen(str)) {
                   sprintf(errmsg,
                   "Level id is missing after DTG in the '-v5d' option\n");
                   goto BYE;
                }

             /* extract level, make sure it's allowed by Vis 5D  */
             if (sscanf (str, "%d", &v5d_info.zdef_lvl)!= 1) {
                   sprintf(errmsg,"Invalid Lvl_id=%s in option -v5d\n",str);
                   goto BYE;
                }
	     else if (v5d_info.zdef_lvl != 100 && v5d_info.zdef_lvl != 103 
		&& v5d_info.zdef_lvl != 105 ) {

		/* removed 11/17/97:  
		&& v5d_info.zdef_lvl != 107 && v5d_info.zdef_lvl != 230) 
		*/
                   sprintf(errmsg,"Level %s is not acceptable.  "\
		   "Option -v5d only accepts 1 of these levels "\
		   "{ 100,103,105,/#107,230#/ }\n",str);
                   goto BYE;
                }

            /* check for Optional vis5D Output filename  */
            if ((str=argv[i+1]) != (char *)0 && *str!='-') {
               if (!(v5d_outfile= malloc(strlen(str))))
                  {sprintf(errmsg,"%s:  failed to get name of v5d outfile\n", 
		   func);goto BYE;}
                else strcpy (v5d_outfile, argv[++i]);
            }

	     v5d_info.usGeom  = USHRT_MAX; /* will default to 1st msg's geom*/
	     v5d_info.usModel = USHRT_MAX; /* will default to 1st msg's model*/
	     Make_V5d = 1;

	     DPRINT3("Vis5D run with DTG=%ld, Level=%d, Outfile=%s\n",
	     v5d_info.base_dtg, v5d_info.zdef_lvl, v5d_outfile);
	     if (v5d_info.zdef_lvl == 105)  fprintf (stdout,
	     "vis5d will process Levels 001 & 102 as Level 105 with Ht=0\n");
#endif
	}
    else if (!strcmp (str, "-I")) {  /* CREATE INDEX */
             if (Build_Index ||(str=argv[++i]) == NULL || *str=='-') {
               	sprintf (errmsg,
	        "%s: use option '-I' Once followed by Indexfilename", func); 
		goto BYE; 
	        }
	     if (Read_Index == 1) {  /* already reading frm indx file */
		sprintf(errmsg,
		"%s:  cannot use -I and -X options together\n",func);
		goto BYE;
		}
             IndexFileName = str;
             Build_Index = 1;
        }
    else if (!strcmp (str, "-X")) {  /* READ INDEX */
             if (Read_Index || (str=argv[++i]) == NULL || *str=='-') {
               	sprintf (errmsg,
	        "%s: use Option '-X' Once followed by Index filename", func); 
		goto BYE; 
	        }
	     if (Build_Index == 1) {  /* already creating frm indx file */
		sprintf(errmsg,
		"%s:  cannot use -X and -I options together\n",func);
		goto BYE;
		}
             IndexFileName = str;
             Read_Index = 1;
        }
    else if (!strcmp (str, "-g")) {
	     Make_Grads =1;
             grad_info.ulGrid_size= 999; /* def. to 1st msg */
	     memset ((void*) &grad_gds, '\0', sizeof(grid_desc_sec));

             /* check if Optional DTG and LVL pair was entered */

             if ( !(str=argv[++i]) || strlen(str) != 10
                        || strspn(str,"0123456789") != 10) 
		{
                  	/* no DTG:   default to 1st msg's info; */
                        grad_info.ebase_dtg=999.; /* epochal time */
                        grad_info.base_dtg= 999;
                        grad_info.zdef_lvl= 999;
			--i;   /* didn't use it so back up one  */
                        continue;
                }

	     /* extract dtg */
             if (sscanf (str, "%d", &grad_info.base_dtg)!= 1) {
                   sprintf(errmsg,
		 "Invalid DTG='%s' in option -g (expecting yyyymmddhhmm)\n"
		   , str);  goto BYE; 
		}

             /* if DTG was entered, must also have Level */
             if ( !(str=argv[++i]) || !strlen(str) || 
		   strspn(str,"0123456789")!=strlen(str)) {
                   sprintf(errmsg, 
		   "Levelid is required after DTG in the '-g' option\n");
		   goto BYE;
                }

	     /* extract level */
             if (sscanf (str, "%d", &grad_info.zdef_lvl)!= 1) {
                   sprintf(errmsg,"Invalid Lvl_id=%s w/ option -g\n",str); 
		   goto BYE;
                }

	     /* convert dtg to epochal time */
             date.year  = (grad_info.base_dtg / 1000000);
             date.month = (grad_info.base_dtg / 10000)%100;
             date.day   = (grad_info.base_dtg / 100)%100;
             hour = (double)(grad_info.base_dtg % 100);
             h_e_time (&date, &hour, &grad_info.ebase_dtg);

             DPRINT3(
             "Command Line Grads Info:  base=%ld (epoch=%f), zdef=%d\n",
             grad_info.base_dtg, grad_info.ebase_dtg, grad_info.zdef_lvl);
	}
    else {   sprintf(errmsg,"%s: '%s' is an Invalid Option", func,str); 
  	     goto BYE;	
         }

/*
* B.2       IF (creating a log file) THEN
*              REMOVE any existing log file
*           ENDIF
*/
   if (make_log) remove("GRIB.log");

/*
*
* B.3       IF (not creating log file AND not creating Binary output file
*                AND not creating Index file 
*                AND not doing Grads AND not doing Vis5D
*                AND not doing 'dump' nor 'print' to screen
*           THEN
*              PRINT error & Return error;
*           ENDIF
*/
   if (!make_log && !output_flag && !Build_Index && !Make_Grads && !Make_V5d
	&& !dump && !Prt_Internals ) 
   {
       if (version_requested == '\0' || InFile != NULL) 
		fprintf (stdout,
		"\n%s: No request to do anything, Exiting...\n",func);
       stat = +1;	/* not an error but still signal program to exit  */
       goto BYE;
   }

/*
*
* B.4       IF (no Input filename)  THEN
*              PRINT Correct Usage menu & Return error;
*           ENDIF
*/
   if (InFile == NULL ) {
       sprintf (errmsg,"%s:  use option -i to specify an input filename",
       func);
       goto BYE;
   }

/*
*
* B.5       IF (table lookup requested) THEN
*/
  if (UseTables) 
  {
/*
* B.5.1         IF (path of Lookup table is undefined) THEN
*/
    if (Table_Path==NULL) {
        DPRINT0("-D option used w/ no path, use Environment var GRIB_ENV\n");
/*
* B.5.1.1           USE the environment variable GRIB_ENV
* B.5.1.2           IF (Env.variable GRIB_ENV is not defined or is null) 
*                   THEN use the Gribsimp's predefined TABLE_PATH var instead
*                   ELSE use GRIB_ENV/tables
*/
        ddir= getenv("GRIB_ENV");

        if (ddir==NULL || *ddir=='\0') {
		Table_Path=(char*)malloc(sizeof(TABLE_PATH)+1);
		if (!Table_Path) {
		   sprintf(errmsg,"%s: failed to malloc TablePath\n",func);
		   goto BYE;
		  }
                strcpy (Table_Path, TABLE_PATH);
                fprintf(stdout,
                "... Environment variable GRIB_ENV not defined\n"\
                "... Default to predefined path= '%s'\n\n",Table_Path);
           }
        else {  
		Table_Path=(char*)malloc(strlen(ddir)+1+strlen("/tables"));
		if (!Table_Path) {
		   sprintf(errmsg,"%s: failed to malloc TablePath (ddir)\n",
		   func);
		   goto BYE;
	         }
		sprintf (Table_Path, "%s/tables", ddir);
                DPRINT1 ("Table Path is '%s'\n", Table_Path); 
	     }
/*
* B.5.1         ENDIF  ! no table path yet
*/
      }  /* no tablepath yet */

/*
* B.5.2         REMOVE all the trailing '/' from the path
*/
    for (i= strlen(Table_Path)-1; i>0 && Table_Path[i] == '/'; )
        Table_Path[i--] = '\0'; 	/* remove trailing /'s */

/*
* B.5.3         IF (path is not a valid directory) THEN
*                   PRINT error
*                   EXIT
*               ENDIF
*/
    if ((dfd= opendir(Table_Path)) == NULL) {
       sprintf(errmsg,"%s:  Invalid Table Path '%s'", func,Table_Path);
       goto BYE;
      }
    closedir (dfd);
    DPRINT1 ("'%s' is a valid directory\n", Table_Path);

/*
* B.5       ENDIF  !UseTables
*/
  }

/*
*
* B.6       DEBUG print
*/
   DPRINT5("Debugging Turned on!!\nCommand line results =\n"\
     "  InFile='%s' \n"\
     "  make_log=%d (GRIB.log), output_flag=%d, SkipBitmap=%d, Prt_Internals=%d\n"\
     ,InFile,make_log,output_flag,SkipBitmap, Prt_Internals);
   DPRINT5 ( "  UseTables=%d, grib_defn=%d \n"\
     "  Make_Grads=%d  basedtg=%d Zdeflvl=%d\n" \
     ,UseTables,grib_defn, Make_Grads, grad_info.base_dtg, grad_info.zdef_lvl);
#ifdef V5D_ON
   DPRINT3 ("  Make_V5d=%d  dtg=%d lvl=%d\n" \
     ,Make_V5d,  v5d_info.base_dtg, v5d_info.zdef_lvl);
#endif
   DPRINT6 (
     "  [user_table=%d Table_Path='%s' Table_Name='%s'] \n"\
     "  [Read_Index=%d Build_Index=%d, IndexFileName='%s']\n\n",
     user_table,Table_Path,Table_Name,Read_Index,Build_Index,IndexFileName);

/*
*
* B.7       IF (creating index file)
*              OPEN index file for writing !EXIT on error
*              WRITE header line to index file  !leave open
*           ENDIF
*/
  if(Build_Index) 
  {
    if((IndexFile = fopen (IndexFileName, "w")) == NULL) {
         sprintf (errmsg,"%s: Can't open indexfile %s",func,IndexFileName );
         goto BYE; }
    fprintf(IndexFile, "YY-MM-DD-HR-TAU-PID-SUB-LID-LEVEL-GDS-OFFSET\n");
  }

/*
*
* B.8       IF (extracting messages using index file)
*              OPEN Index file for reading      !EXIT on error
*              /# DISCARD 1st line of index file   !Title line #/
*           ENDIF
*/
  if(Read_Index) {
    if ((IndexFile = fopen(IndexFileName, "r")) == NULL ) {
         sprintf (errmsg,"%s: Can't open indexfile %s",func,IndexFileName );
         goto BYE; }
    /*fscanf(IndexFile, "%s", temp);  skip over Title line in Indx file */
  }

/*
*
* B.9       SET Return status to 0 ! no errors
*/
  stat = 0;

BYE:
  DPRINT2 ("Exiting  %s, stat= %d\n", func, stat);
  return (stat);
/*
*
* END OF FUNCTION
*
*
*/
}
/*
* =====================================================================
* C.  FUNCTION: next_index_entry
*     PURPOSE:  retrieve the byte offset of next Msg to decode from Indexfile;
*     ARGS   :
*        long *offset;   if ok, holds byte offset fr. beginning of file;
*        char *errmsg;   empty unless error occurs;
*     RETURNS:  
*      -1:  failed, got error reading; file is now closed;
*       0:  no errors, offset stored in argument;
*      +1:  got end of file;  offset is -1L, errmsg left empty;
* =====================================================================
*/
#if PROTOTYPE_NEEDED
int	next_index_entry (long	*offset, char    *errmsg)
#else
int	next_index_entry (offset, errmsg)
long	*offset;
char    *errmsg;
#endif
{
char	*p,*ptr, line[200], *func="next_index_entry";
int     cnt, status;

    DPRINT1 ("Entering %s\n", func);
/*
* C.1      WHILE no errors reading Index file DO
*              READ next line from the file 
*              IF (fails) return with error
*              LOOP if line contains all spaces
*              LOCATE the '-' before offsetvalue in line read
*              LOOP and skip this line if no dash was found
*              IF (no offset avail after dash) THEN
*                  QUIT  !got error 
*              ELSE
*                  STORE the byte offset
*                  RETURN with no errors
*              ENDIF
*          ENDWHILE
*/
    while ( !ferror(IndexFile) && !feof(IndexFile))
    {
        if (fgets (line, sizeof(line)-1, IndexFile) == NULL)  {
	   sprintf (errmsg, "%s: error reading entry from Indexfile",func);
	   break;
	}
	if ((ptr= strchr(line, '\n')) != NULL) *ptr = '\0';

	/* skip over leading spaces */
        for (cnt=0; cnt < strlen(line) && isspace(line[cnt]); cnt++)  ;
	if (cnt == strlen(line)) continue; /* skip if line is all spaces */

	/* locate last dash on line, skip if none  */
	if ((ptr= strrchr (line, '-')) == NULL ) continue;
	/* make sure there is a number after last dash */
	if (!isdigit (*(ptr+1))) {
		DPRINT1("No number after last dash, skip (%s)\n", line);
		continue;  /* break; */
		}
	else {  /* else get the Byte Offset value */
		*offset = atol (ptr+1); 
		DPRINT1 ("next msg's offset is at %ld\n", *offset);
		status=0; 
		goto BYE; 
	      }
    }

/*
*
* C.2      IF (end of file) RETURN with status 1
*          ELSE return with error status -1
*/
    if (feof(IndexFile))  
	 { DPRINT0 ("saw eof (indexfile)\n");
	   /*  *offset=-1L; */
	   errmsg[0] ='\0';
	   status= 1; /* EOF */
	 }
    else status= (-1);	/* Errormsg filled  */

BYE:
    DPRINT2 ("Exiting %s, Status=%d\n", func, status);
    return (status);
/*
*
* END OF FUNCTION
*
*/
}

/*
* =====================================================================
* D.  FUNCTION: Process_v5d
*
*     PURPOSE:  retrieve the byte offset of next Msg to decode from Indexfile;
*        Will exit with no error if projection of this message is not one of 
*        the ones supported:  Lat/Lon (Spherical) and Lambert.
*
*     ARGUMENTS:
*        long offset;   if ok, holds byte offset fr. beginning of file;
*        char *errmsg;   empty unless error occurs;
*
*     RETURNS:  
*       0:  no errors;
*       1:  failed;  errmsg is filled;
* =====================================================================
*/

#if PROTOTYPE_NEEDED
int	Process_v5d (long offset, char *errmsg)
#else
int	Process_v5d(offset, errmsg)
long	offset;
char    *errmsg;
#endif
{
char	*func= "Process_v5d";	/* Func name */
int	idtg;		/* current date time group  */
int	nReturn= 1;	/* exit code */
REG_GEOM  geom;   	/* Neons style */
double 	X1, Y1; 	/* working vars */
long    ltemp;		/* working var */
double  dlat;
float   lon1,lon2, latpick,lonpick;
int  ld_v5d_msg ( long GRIB_offs, PDS_INPUT pds, grid_desc_sec gds, 
	BDS_HEAD_INPUT  bds_head, BMS_INPUT bms, 
	int  *tot_parms, int  *tot_msgs,
        V5D_LVL         **lvl_head,
        V5D_PARM        **parm_head, V5D_PARM   **parm_tail,
        V5_REC          **msgs_head, V5_REC     **msgs_tail,
        V5_INFO         *v5_info, char            *errmsg);

#ifdef V5D_ON
    /*** NOTE ***
	Allowing levels 1 and 102 to come through.  These will be treated 
	as level 105 with height 00000.  It is assumed that all of these
	mesgs with levels 001 and 102 all have Height=00000;
     ************/
	/* Calculate this msg's Date Time Group  */
        idtg = (pds.usCentury-1)*100000000 + pds.usYear*1000000 +
                pds.usMonth*10000 + pds.usDay*100 + pds.usHour;

	/* Check msg's base time versus User-given base time 
	   Donot accept if msg's time is older than User's time
	*/
	if (idtg < v5d_info.base_dtg ) {  	/* Reject it  */
	   fprintf(stdout, "Vis5d rejects this msg because IDTG < %ld\n",
	   v5d_info.base_dtg);
	   nReturn = 0; /* no errors */
	   goto bail_out;
	}	


     /* Accept V5D msg */
        if ((nReturn= ld_v5d_msg (offset, pds, gds, bds_head, bms, 
		     	&v5d_parm_cnt, &v5dcnt,
		     	&v5d_lvl_head, &v5d_parm_head, &v5d_parm_tail, 
		     	&v5d_msgs_head, &v5d_msgs_tail,
		     	&v5d_info, errmsg) ) != 0) 	
	    goto bail_out;


     /* Load data that's constant for entire dataset if haven't */
     if (v5d_info.nrows==0 || v5d_info.ncols == 0) 
      {
	DPRINT0 ("Initialize V5D_INFO=\n");
	v5d_info.usGeom  = pds.usGrid_id;
	v5d_info.usModel = pds.usProc_id;  

	switch (gds.head.usData_type)    /* Projection Info */
	{
	case LATLON_PRJ:  /* Spherical */
	    DPRINT4 ( "\tSpherical projection=\n"\
	    "\tgds.llg.lLat1= %ld, gds.llg.lLon1=%ld,\n"\
	    "\tgds.llg.lLat2= %ld, gds.llg.lLon2=%ld \n",
	    gds.llg.lLat1, gds.llg.lLon1, gds.llg.lLat2, gds.llg.lLon2);

	    v5d_info.nrows= gds.llg.usNj;
	    v5d_info.ncols= gds.llg.usNi; 
	    v5d_info.v5d_proj= 1;  	/* according to Vis5d */

	    /* make Lon is going 0-360, West to East */
	    { 
		lon1 = (float)gds.llg.lLon1 / 1000.;
		lon2 = (float)gds.llg.lLon2 / 1000.;
		lon1 = (lon1 < 0. ? lon1 + 360: lon1);
		lon2 = (lon2 < 0. ? lon2 + 360: lon2);
		/* get Western-most Longitude */
		lonpick = (lon1 > lon2 ? lon1 : lon2); 
		/* convert to Vis5d coordinate (-180 to +180) */
		if (lonpick >= 180) 
			    lonpick= 360-lonpick;
		    else    lonpick = -1 *lonpick;
		/* pick Northernmost Latitude */
	        latpick = (float)(gds.llg.lLat1 > gds.llg.lLat2 ? 
			    gds.llg.lLat1 : gds.llg.lLat2) /1000.; 
    
	        v5d_info.proj_args[0]= (float)latpick ; 
	        v5d_info.proj_args[1]= (float)lonpick ;  
	    }
	    v5d_info.proj_args[2]= (float)gds.llg.iDj /1000.;
	    v5d_info.proj_args[3]= (float)gds.llg.iDi /1000.;
	    v5d_info.proj_args[4]= 0.;  /* not used */
	    v5d_info.proj_args[5]= 0.;  /* not used */
	    v5d_info.proj_args[6]= 0.;  /* not used */
	    break;

       case LAMB_PRJ:  /* Lambert */
	    v5d_info.nrows= gds.lam.iNy;
	    v5d_info.ncols= gds.lam.iNx; 
	    v5d_info.v5d_proj= 2;  /* Vis5d projection */
		    
  	    /* Make sure Latcut1 is greater or equal to Latcut2 */
	    if (gds.lam.lLat_cut1 < gds.lam.lLat_cut2) {
		ltemp = gds.lam.lLat_cut2;
		gds.lam.lLat_cut2 = gds.lam.lLat_cut1;
		gds.lam.lLat_cut1 = ltemp;
		}

	    if (gds.lam.lLat_cut1 * gds.lam.lLat_cut2 < 0) {
		sprintf(errmsg,
		"%s: Invalid vis5d geometry; Latcut1=%ld, Latcut2=%ld"\
		"\nLatcut1/2 must be in same hemisphere",
		func, gds.lam.lLat_cut1, gds.lam.lLat_cut2);
		nReturn = 1;
		goto bail_out;
		}
		    
	     { /* grad_boundry: line 135- */
		strcpy (geom.prjn_name, "lambert");
		geom.nx = gds.lam.iNx;
		geom.ny = gds.lam.iNy;
		geom.lat = (double)gds.lam.lLat1/1000.;
		geom.lon = (double)gds.lam.lLon1/1000.;
		if (geom.lon < -180.) geom.lon+= 360.;
		else if (geom.lon > 180) geom.lon -= 360.;
		geom.x_int_dis = (double)gds.lam.ulDx /1000.;
		geom.y_int_dis = (double)gds.lam.ulDy /1000.;
		geom.parm_1 = (double)gds.lam.lLat_cut1/1000.;
		geom.parm_2 = (double)gds.lam.lLat_cut2/1000.;
		geom.parm_3 = (double)gds.lam.lLon_orient/1000.;
		if (geom.parm_3 < -180.) geom.parm_3+= 360.;
		else if (geom.parm_3 > 180) geom.parm_3 -= 360.;
		strcpy (geom.stor_dsc, "+x in -y");

	      /*
	      * CONVERT GRIB's origin (any corner) to DATABASE's origin
	      * (always left top corner)=
	      * !Depending on the Scan Mode, find Orig_ix & Orig_iy =
	      * !  if GRIB scans in +I dir, set Db's orig_ix= col 1;
	      * !  if GRIB scans in -I dir, set Db's orig_ix= #cols;
	      * !  if GRIB scans in -J dir, set Db's orig_iy= row 1;
	      * !  if GRIB scans in +J dir, set Db's orig_iy= #rows, opts=YREV;
	      * !FUNCTION xy_latlon  !convert X/Y coords to Lat/Lon
	      * !initializes xdef, ydef, options strings
	      */
	       DPRINT1( "LAM.usScan_mode= %d\n", gds.lam.usScan_mode);

		switch (gds.lam.usScan_mode) {
		 case   0: /* GRIB's 1st pt is top Left  (+i,-j, Horiz first) */
			geom.orig_ix= (double) 1; 
			geom.orig_iy= (float) 1; break;
	    
		 case  0x20:  /* dec. 32 */
			/* GRIB's 1st pt is top Left (+i,-j, Vertical first) */
			geom.orig_ix= (double) 1; 
			geom.orig_iy= (float) 1; break;
	    
		 case  0x40:  /* dec. 64 */
			/* GRIB's 1st pt is Bottom Left (+i,+j, Horiz first) */
			geom.orig_ix= (double) 1;
			geom.orig_iy= (float) gds.lam.iNy; break;
	    
		 case  0x60: /* dec. 96 */
			/* GRIB's 1st pt is Bottom Left (+i,+j, Verticl first)*/
			geom.orig_ix= (double) 1;
			geom.orig_iy= (float) gds.lam.iNy; break;
	    
		 case 0x80: /* dec. 128 */
			/* GRIB's 1st pt is Top Right (-i,-j, Horiz first) */
			geom.orig_ix= (double) gds.lam.iNx;
			geom.orig_iy= (float) 1; break;
	    
		 case 0xA0: /* dec. 192 */
			/* GRIB's 1st pt is Top Right (-i, -j, Vertical first)*/
			geom.orig_ix= (double) gds.lam.iNx;
			geom.orig_iy= (float) 1; break;
	    
		 case 0xC0: /* dec. 160 */
			/* GRIB's 1st pt is Bottom Right (-i,+j, Horiz first) */
			geom.orig_ix= (double) gds.lam.iNx;
			geom.orig_iy= (float) gds.lam.iNy; break;
	    
		 case 0xE0: /* dec. 224 */
			/* GRIB's 1st pt is Bottom Right (-i,+j,Verticl first)*/
			geom.orig_ix= (double) gds.lam.iNx;
			geom.orig_iy= (float) gds.lam.iNy; break;

		 default : sprintf(errmsg,"%s:  Invalid Scanmode=%d\n",
			func, gds.lam.usScan_mode); 
			nReturn = 1;
			goto bail_out;
		}

		DPRINT8 ("\nGEOM: '%s', nx=%d, ny=%d, lat=%.2f, lon=%.2f, "\
		"x_int_dis=%.2f,\ny_int_dis=%.2f, parm1=%.2f",
		geom.prjn_name, geom.nx, geom.ny, geom.lat, geom.lon,
		geom.x_int_dis, geom.y_int_dis, geom.parm_1);
		DPRINT4 ( ", parm2=%.2f, parm3=%.2f\n"\
		"orig_ix= (double)%f orig_iy= (float)%f\n"
		,geom.parm_2,geom.parm_3,geom.orig_ix,geom.orig_iy);
    	     } /* grad_boundry: line 462 */
		    
	     /*
	     Compute coordinates of north/south pole depending on hemisphere
	     */
	     if (gds.lam.lLat_cut1 > 0) {
		  dlat = NORTHPOLE;
		  latlon_xy (&geom, &dlat, &geom.parm_3, &X1, &Y1, &nReturn);
		}
      	     else {
		  dlat= SOUTHPOLE;
		  latlon_xy (&geom, &dlat, &geom.parm_3, &X1, &Y1, &nReturn);
		}
		    
	      if (nReturn!=0) {
		 sprintf(errmsg,"%s: latlon_xy call has error %d\n", 
		func, nReturn);
		 goto bail_out;
	        }
		    
	      /* convert to Vis5d coordinate (-180 to +180) */
	       lonpick = (float) geom.parm_3;
	       if (lonpick>=180) lonpick= 360-lonpick; else lonpick= -1*lonpick;

		v5d_info.proj_args[0]= (float)geom.parm_1;
		v5d_info.proj_args[1]= (float)geom.parm_2;
		v5d_info.proj_args[2]= (float) Y1;
		v5d_info.proj_args[3]= (float) X1;
		v5d_info.proj_args[4]= lonpick;
		v5d_info.proj_args[5]= (float)geom.x_int_dis;

	        DPRINT2 ( "Lambert:  v5d_info.nrows=%d, v5d_info.ncols=%d\n",
		v5d_info.nrows, v5d_info.ncols);
		break;

	  default:  fprintf(stdout,
		"WARNING %s:  Vis5d option does not support projection %d\n", 
		func, gds.head.usData_type);
		return 0;

        } /* SWitch */

	DPRINT7 (
	"\tv5d_info.nrows=%d, v5d_info.ncols=%d,  V5dProj=%d\n"\
	"\tProjArg[0]=%f\n\tProjArg[1]=%f\n\tProjArg[2]=%f\n\tProjArg[3]=%f\n",
	v5d_info.nrows, v5d_info.ncols, v5d_info.v5d_proj,
	v5d_info.proj_args[0], v5d_info.proj_args[1],v5d_info.proj_args[2],
	v5d_info.proj_args[3]);
	DPRINT3 ("\tProjArg[4]=%f\n\tProjArg[5]=%f\n\tProjArg[6]=%f\n",
	v5d_info.proj_args[4],v5d_info.proj_args[5],v5d_info.proj_args[6]);
      }  /* init v5d_Info */

     /* print out what we have sofar:
	fprintf(stdout,"V5D vars =");
	for (tmp_parm=v5d_parm_head; tmp_parm; tmp_parm=tmp_parm->next)
		fprintf(stdout,"%s ", tmp_parm->abbrv); fprintf(stdout,"\n");
	fprintf(stdout,"V5D Level #%d has Heights= [",
		 v5d_lvl_head->usLevel_id);
	for (tmp_lvl=v5d_lvl_head, i=0; i<tmp_lvl->numheights; ++i)
		fprintf(stdout," %d;",tmp_lvl->height[i]);fprintf(stdout,"]\n");
	for (v5dmsg=v5d_msgs_head ; v5dmsg; v5dmsg=v5dmsg->next)
		fprintf(stdout,"V5D Mesg=> %ld P1=%d '%s'", 
		v5dmsg->base_dtg, v5dmsg->usP1, v5dmsg->parm_ptr->abbrv);
	fprintf(stdout,"\n");
	*/

    fprintf(stdout,
    "V5DMSG: %02u%02u%02u%02u tau=%03u, Parm=%03u Sub=%03u Lvl=%03u (Ht=%05u)\n"
    , pds.usYear, pds.usMonth, pds.usDay, pds.usHour,
    pds.usP1, pds.usParm_id, pds.usParm_sub, pds.usLevel_id, pds.usHeight1);

    nReturn = 0;

bail_out:
    DPRINT2 ("Leaving %s, return code=%d\n", func, nReturn);
    return (0);

#else
   fprintf(stdout,
   "'%s'  is only available when program was compile with vis5d extensions\n",
   func);
   return(0);
#endif
}
